<!DOCTYPE html>
<html>
<head>
    <title>Heart Rate Detector</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 30px;
            text-align: center;
            background: #f5f6fa;
        }
        .card {
            max-width: 900px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 14px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            padding: 24px 22px;
        }
        video {
            position: absolute;
            right: 12px;
            bottom: 12px;
            width: 120px;
            height: 120px;
            border-radius: 10px;
            background: black;
            object-fit: cover;
            display: block;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 3;
        }
        #startBtn {
            padding: 12px 22px;
            border: none;
            background: #007bff;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
        }
        #stopBtn {
            padding: 12px 22px;
            border: none;
            background: #e11d48;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin-left: 8px;
        }
        #bpm {
            margin-top: 25px;
            font-size: 28px;
            font-weight: bold;
        }
        #instructions {
            margin: 20px 0;
            font-size: 16px;
        }
        #status {
            color: #475569;
            font-size: 14px;
            margin-top: 8px;
        }
        .viz-wrap {
            position: relative;
            margin: 24px auto 8px auto;
            width: 100%;
            max-width: 900px;
        }
        #viz {
            width: 100%;
            height: 180px;
            display: block;
            background: linear-gradient(180deg, #0b1220 0%, #0f172a 100%);
            border-radius: 10px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
        }
        .pulse {
            position: absolute;
            left: 50%;
            top: calc(50% - 8px);
            transform: translate(-50%, -50%) scale(1);
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at 30% 30%, #ff7ab3, #e11d48);
            border-radius: 999px;
            box-shadow: 0 0 0 0 rgba(225, 29, 72, 0.6);
            pointer-events: none;
        }
        .pulse.beat {
            animation: pulseBeat 350ms ease-out;
        }
        @keyframes pulseBeat {
            0% { transform: translate(-50%, -50%) scale(0.9); box-shadow: 0 0 0 0 rgba(225,29,72,0.65); }
            70% { transform: translate(-50%, -50%) scale(1.25); box-shadow: 0 0 24px 12px rgba(225,29,72,0.08); }
            100% { transform: translate(-50%, -50%) scale(1.0); box-shadow: 0 0 0 0 rgba(225,29,72,0.0); }
        }
        .metrics {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 14px;
            margin-top: 8px;
            color: #1f2937;
        }
        .bpm-badge {
            padding: 6px 10px;
            border-radius: 999px;
            background: #eef2ff;
            color: #3730a3;
            font-weight: 700;
            font-size: 14px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.04) inset;
        }
        /* Result overlay */
        .result-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(12px);
            background: rgba(15, 23, 42, 0.45);
            z-index: 20;
            padding: 24px;
        }
        .result-overlay.show {
            display: flex;
        }
        .result-modal {
            width: 100%;
            max-width: 740px;
            background: #000000;
            color: #ffffff;
            border-radius: 32px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.35);
            padding: 28px 24px 32px 24px;
        }
        .heart-hero {
            display: grid;
            place-items: center;
            margin: 12px 0 16px 0;
            position: relative;
        }
        .heart-shape {
            position: relative;
            width: 200px;
            height: 200px;
            transform: rotate(-45deg);
            background: radial-gradient(circle at 30% 30%, #ff89c2 0%, #ff2c78 45%, #b90b4b 100%);
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(255, 44, 120, 0.35), inset 0 0 0 4px rgba(255,255,255,0.12);
        }
        .heart-shape:before,
        .heart-shape:after {
            content: "";
            position: absolute;
            width: 200px;
            height: 200px;
            background: inherit;
            border-radius: 50%;
            box-shadow: inherit;
        }
        .heart-shape:before {
            top: -100px;
            left: 0;
        }
        .heart-shape:after {
            left: 100px;
            top: 0;
        }
        .heart-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-weight: 800;
            text-shadow: 0 2px 10px rgba(0,0,0,0.35);
        }
        .heart-value .num {
            font-size: 64px;
            line-height: 1;
        }
        .heart-value .unit {
            font-size: 18px;
            opacity: 0.9;
            letter-spacing: 1px;
            margin-top: 6px;
        }
        .hr-table {
            margin-top: 18px;
            border-top: 1px solid rgba(255,255,255,0.08);
        }
        .hr-row,
        .hr-header {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            padding: 14px 6px;
        }
        .hr-header {
            font-weight: 700;
            opacity: 0.95;
        }
        .hr-row {
            border-top: 1px solid rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.95);
        }
        .modal-actions {
            display: flex;
            justify-content: center;
            margin-top: 18px;
        }
        .modal-actions .again-btn {
            padding: 12px 22px;
            border: none;
            background: #22c55e;
            color: #052e16;
            border-radius: 999px;
            font-weight: 800;
            cursor: pointer;
            font-size: 16px;
        }
        @media screen and (max-width: 740px), screen and (hover: none) and (pointer: coarse) {
            .result-modal {
                border-radius: 28px;
                padding: 22px 18px 26px 18px;
                margin: 0 8px;
            }
            .heart-shape {
                width: 190px;
                height: 190px;
            }
            .heart-shape:before,
            .heart-shape:after {
                width: 190px;
                height: 190px;
            }
            .heart-value .num {
                font-size: 60px;
            }
        }
        /* Responsive adjustments to match mobile UI */
        @media screen and (max-width: 740px), screen and (hover: none) and (pointer: coarse) {
            body {
                padding: 0;
                background: #0b1220;
            }
            .card {
                max-width: 100%;
                border-radius: 0;
                box-shadow: none;
                padding: 24px 16px 110px 16px; /* leave room for bottom button */
                background: #ffffff;
            }
            .card h2 {
                font-size: 38px;
                margin: 8px 0 6px 0;
            }
            #instructions {
                font-size: 18px;
                color: #8a8f98;
                margin-bottom: 12px;
            }
            .viz-wrap {
                margin: 0 -16px;
                width: calc(100% + 32px);
            }
            #viz {
                height: 56vh;
                border-radius: 0;
            }
            .metrics {
                position: absolute;
                top: 24px;
                left: 0;
                right: 0;
                margin: 0;
                z-index: 2;
                color: #ffffff;
            }
            .bpm-badge {
                background: transparent;
                color: #ffffff;
                font-size: 56px;
                padding: 0;
                box-shadow: none;
            }
            /* Start/Stop as a single bottom pill; show only the active (not disabled) one */
            #startBtn, #stopBtn {
                position: fixed;
                left: 20px;
                right: 20px;
                bottom: calc(24px + env(safe-area-inset-bottom));
                height: 64px;
                font-size: 22px;
                border-radius: 999px;
                box-shadow: 0 10px 24px rgba(0,0,0,0.2);
                z-index: 5;
            }
            #startBtn {
                background: #178a00;
            }
            #stopBtn {
                background: #e11d48;
            }
            button:disabled {
                display: none;
            }
            /* Camera preview slightly larger */
            video#video {
                width: 140px;
                height: 140px;
                right: 16px;
                bottom: 16px;
                border-radius: 14px;
            }
        }
    </style>
</head>
<body>

    <div class="card">
        <h2>Heart Rate Detector</h2>

        <p id="instructions">Place your fingertip over the camera + Flashlight</p>

        <button id="startBtn">Start Measuring</button>
        <button id="stopBtn">Stop</button>

        <div class="viz-wrap">
            <canvas id="viz"></canvas>
            <div id="pulse" class="pulse"></div>
            <div class="metrics">
                <span class="bpm-badge" id="bpm">BPM: --</span>
            </div>
            <video id="video" autoplay playsinline muted></video>
        </div>

        <p id="status">Ready.</p>
    </div>

    <!-- Final Result Modal -->
    <div id="resultOverlay" class="result-overlay" aria-hidden="true">
        <div class="result-modal" role="dialog" aria-modal="true" aria-labelledby="resultTitle">
            <div class="heart-hero">
                <div class="heart-shape"></div>
                <div class="heart-value">
                    <div id="resultTitle" class="num">--</div>
                    <div class="unit">BPM</div>
                </div>
            </div>
            <div class="hr-table">
                <div class="hr-header">
                    <div>Age Group</div>
                    <div>Heart Rate</div>
                </div>
                <div class="hr-row"><div>Toddler (1 to 3 years)</div><div>80 – 130</div></div>
                <div class="hr-row"><div>Preschool (3 to 5 years)</div><div>80 – 110</div></div>
                <div class="hr-row"><div>School Age (6 to 12 years)</div><div>70 – 100</div></div>
                <div class="hr-row"><div>Adolescents (13 to 18 years) and Adults</div><div>60 – 100</div></div>
            </div>
            <div class="modal-actions">
                <button id="measureAgainBtn" class="again-btn">Measure Again</button>
            </div>
        </div>
    </div>

    <script>
        const video = document.getElementById("video");
const bpmText = document.getElementById("bpm");
const startBtn = document.getElementById("startBtn");
const stopBtn = document.getElementById("stopBtn");
const statusEl = document.getElementById("status");
const vizCanvas = document.getElementById("viz");
const pulseEl = document.getElementById("pulse");
let vizCtx;
const resultOverlay = document.getElementById("resultOverlay");
const resultTitle = document.getElementById("resultTitle");
const measureAgainBtn = document.getElementById("measureAgainBtn");

let stream, track, rafId;
let redValues = []; // { time, value } filtered values
let filteredValue;
let lastPeakTime = 0; // for pulse animation
let running = false;
const SCAN_DURATION_MS = 20000; // 20 seconds
let scanStartTime = 0;
let scanFinalized = false;
let scanningTimeoutId = null;
let countdownIntervalId = null;
let beatTimes = []; // timestamps (performance.now) of detected peaks

// Ensure mobile-responsive CSS applies early when device is coarse pointer
(function ensureMobileViewport() {
    try {
        const isCoarse = window.matchMedia && window.matchMedia("(hover: none) and (pointer: coarse)").matches;
        const isNarrow = window.matchMedia && window.matchMedia("(max-width: 740px)").matches;
        if (isCoarse || isNarrow) {
            document.documentElement.style.setProperty("--mobile", "1");
        }
    } catch (e) {}
})();

function setStatus(msg, isError = false) {
    statusEl.textContent = msg;
    statusEl.style.color = isError ? "#c0392b" : "#333";
}

startBtn.onclick = async () => {
    startBtn.disabled = true;
    stopBtn.disabled = false;
    try {
        setStatus("Requesting camera...");
        await startCamera();
        setStatus("Camera started. Preparing frames...");
        // Ensure we have metadata before processing sizes
        await new Promise(resolve => {
            if (video.readyState >= HTMLMediaElement.HAVE_METADATA) return resolve();
            video.onloadedmetadata = () => resolve();
        });
        initVisualizer();
        startProcessing();
        beginTimedScan();
    } catch (e) {
        console.error(e);
        setStatus("Failed to start: " + (e && e.message ? e.message : e), true);
        startBtn.disabled = false;
        stopBtn.disabled = true;
    }
};

stopBtn.onclick = () => {
    // Manual stop also finalizes with current data
    finalizeScan(false);
};

async function startCamera() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false
        });
    } catch (e) {
        throw new Error("Camera permission denied or unavailable");
    }

    video.srcObject = stream;
    await video.play();

    track = stream.getVideoTracks()[0];

    // Try enabling flashlight if supported
    try {
        const capabilities = typeof track.getCapabilities === "function" ? track.getCapabilities() : {};
        if (capabilities && "torch" in capabilities) {
            await track.applyConstraints({ advanced: [{ torch: true }] });
            console.log("Flashlight ON");
        } else {
            console.log("Torch not supported");
        }
    } catch (e) {
        console.log("Failed to enable torch");
    }
}

function startProcessing() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const SAMPLE_SIZE = 64; // downscale for performance

    running = true;
    filteredValue = undefined;
    redValues = [];
    lastPeakTime = 0;
    beatTimes = [];

    function processFrame() {
        if (!running) return;

        // Ensure we have video frames
        if (video.readyState < HTMLMediaElement.HAVE_CURRENT_DATA ||
            !video.videoWidth || !video.videoHeight) {
            rafId = requestAnimationFrame(processFrame);
            return;
        }

        canvas.width = SAMPLE_SIZE;
        canvas.height = SAMPLE_SIZE;

        // Draw scaled-down frame
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const frame = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

        let redSum = 0;
        // Sum red channel
        for (let i = 0; i < frame.length; i += 4) {
            redSum += frame[i];
        }
        const avgRed = redSum / (frame.length / 4);

        // Exponential moving average to smooth (low-pass)
        const alpha = 0.2;
        filteredValue = filteredValue === undefined ? avgRed : (alpha * avgRed + (1 - alpha) * filteredValue);

        const now = performance.now();
        redValues.push({ time: now, value: filteredValue });

        // Keep last 10 seconds of data
        const windowMs = 10000;
        const cutoff = now - windowMs;
        while (redValues.length && redValues[0].time < cutoff) {
            redValues.shift();
        }

        computeBPM();
        renderWaveform();

        rafId = requestAnimationFrame(processFrame);
    }

    processFrame();
}

function computeBPM() {
    if (redValues.length < 5) return;

    // Dynamic threshold = mean of current window
    const values = redValues.map(v => v.value);
    const threshold = average(values);

    // Find local maxima with minimum peak distance
    const minPeakDistanceMs = 300; // ~200 bpm ceiling
    const peaks = [];
    for (let i = 1; i < redValues.length - 1; i++) {
        const prev = redValues[i - 1];
        const curr = redValues[i];
        const next = redValues[i + 1];
        if (curr.value > threshold && curr.value > prev.value && curr.value > next.value) {
            if (!peaks.length || (curr.time - peaks[peaks.length - 1]) >= minPeakDistanceMs) {
                peaks.push(curr.time);
            }
        }
    }

    // Trigger pulse on new peak
    if (peaks.length) {
        const latest = peaks[peaks.length - 1];
        if (latest > lastPeakTime) {
            lastPeakTime = latest;
            triggerPulse();
            beatTimes.push(latest);
        }
    }

    if (peaks.length > 1) {
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
            intervals.push(peaks[i] - peaks[i - 1]);
        }
        const avgInterval = average(intervals);
        if (avgInterval > 0 && isFinite(avgInterval)) {
            const bpm = Math.round(60000 / avgInterval);
            bpmText.innerText = "BPM: " + bpm;
        }
    }
}

function average(arr) {
    return arr.reduce((a, b) => a + b) / arr.length;
}

function initVisualizer() {
    vizCtx = vizCanvas.getContext("2d");
    const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        const rect = vizCanvas.getBoundingClientRect();
        vizCanvas.width = Math.max(300, Math.floor(rect.width * dpr));
        vizCanvas.height = Math.max(120, Math.floor(rect.height * dpr));
        vizCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    window.addEventListener("resize", resize);
    resize();
}

function renderWaveform() {
    if (!vizCtx) return;
    const width = vizCanvas.width / (window.devicePixelRatio || 1);
    const height = vizCanvas.height / (window.devicePixelRatio || 1);

    // Clear
    vizCtx.clearRect(0, 0, width, height);

    // Grid lines
    vizCtx.strokeStyle = "rgba(255,255,255,0.06)";
    vizCtx.lineWidth = 1;
    vizCtx.beginPath();
    for (let x = 0; x <= width; x += 60) {
        vizCtx.moveTo(x, 0);
        vizCtx.lineTo(x, height);
    }
    for (let y = 0; y <= height; y += 45) {
        vizCtx.moveTo(0, y);
        vizCtx.lineTo(width, y);
    }
    vizCtx.stroke();

    if (redValues.length < 2) return;

    // Take last N points
    const maxPoints = 500;
    const data = redValues.slice(-maxPoints).map(v => v.value);
    const minV = Math.min(...data);
    const maxV = Math.max(...data);
    const range = Math.max(1, maxV - minV);

    // Gradient stroke
    const grad = vizCtx.createLinearGradient(0, 0, width, 0);
    grad.addColorStop(0, "#ff7ab3");
    grad.addColorStop(1, "#00d4ff");

    vizCtx.strokeStyle = grad;
    vizCtx.lineWidth = 2;
    vizCtx.beginPath();

    for (let i = 0; i < data.length; i++) {
        const x = (i / (data.length - 1)) * (width - 10) + 5;
        const norm = (data[i] - minV) / range; // 0..1
        const y = height - (norm * (height - 10)) - 5;
        if (i === 0) vizCtx.moveTo(x, y);
        else vizCtx.lineTo(x, y);
    }
    vizCtx.stroke();

    // Glow overlay
    vizCtx.shadowColor = "rgba(0, 212, 255, 0.2)";
    vizCtx.shadowBlur = 12;
    vizCtx.stroke();
    vizCtx.shadowBlur = 0;
}

function triggerPulse() {
    if (!pulseEl) return;
    pulseEl.classList.remove("beat");
    // Force reflow to restart animation
    // eslint-disable-next-line no-unused-expressions
    pulseEl.offsetWidth;
    pulseEl.classList.add("beat");
}

function beginTimedScan() {
    scanFinalized = false;
    scanStartTime = performance.now();
    // countdown
    if (countdownIntervalId) clearInterval(countdownIntervalId);
    countdownIntervalId = setInterval(() => {
        const remaining = Math.max(0, SCAN_DURATION_MS - (performance.now() - scanStartTime));
        const seconds = Math.ceil(remaining / 1000);
        setStatus("Scanning... " + seconds + "s left");
    }, 250);
    // auto finalize after duration
    if (scanningTimeoutId) clearTimeout(scanningTimeoutId);
    scanningTimeoutId = setTimeout(() => finalizeScan(true), SCAN_DURATION_MS);
}

function computeAverageBpmFromBeats(times) {
    if (!times || times.length < 2) return null;
    const intervals = [];
    for (let i = 1; i < times.length; i++) {
        const dt = times[i] - times[i - 1];
        // accept plausible heart beat intervals ~30-200 bpm => 300-2000ms
        if (dt >= 300 && dt <= 2000) intervals.push(dt);
    }
    if (!intervals.length) return null;
    const avgInterval = average(intervals);
    if (!isFinite(avgInterval) || avgInterval <= 0) return null;
    return Math.round(60000 / avgInterval);
}

function finalizeScan(auto = false) {
    if (scanFinalized) return;
    scanFinalized = true;
    if (countdownIntervalId) {
        clearInterval(countdownIntervalId);
        countdownIntervalId = null;
    }
    if (scanningTimeoutId) {
        clearTimeout(scanningTimeoutId);
        scanningTimeoutId = null;
    }
    // Compute average BPM from collected beats within scan window
    const beats = beatTimes.filter(t => t >= scanStartTime && t <= scanStartTime + SCAN_DURATION_MS);
    const avgBpm = computeAverageBpmFromBeats(beats);
    // Stop measurement and camera
    stop();
    if (avgBpm) {
        bpmText.innerText = "BPM: " + avgBpm;
        setStatus("Scan complete. Final BPM: " + avgBpm);
        showResultModal(avgBpm);
    } else {
        setStatus("Scan complete. Not enough signal to compute BPM.", true);
        showResultModal(null);
    }
}

function stop() {
    running = false;
    if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
    }
    if (track) {
        try {
            const capabilities = typeof track.getCapabilities === "function" ? track.getCapabilities() : {};
            if (capabilities && "torch" in capabilities) {
                track.applyConstraints({ advanced: [{ torch: false }] }).catch(() => {});
            }
        } catch (e) {}
    }
    if (stream) {
        stream.getTracks().forEach(t => t.stop());
    }
    stream = null;
    track = null;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    setStatus("Stopped.");
}

// Initialize buttons state
stopBtn.disabled = true;

// Modal helpers
function showResultModal(bpm) {
    if (typeof bpm === "number" && isFinite(bpm)) {
        resultTitle.textContent = bpm;
    } else {
        resultTitle.textContent = "--";
    }
    resultOverlay.classList.add("show");
    resultOverlay.setAttribute("aria-hidden", "false");
}

function hideResultModal() {
    resultOverlay.classList.remove("show");
    resultOverlay.setAttribute("aria-hidden", "true");
}

measureAgainBtn.addEventListener("click", () => {
    hideResultModal();
    startBtn.click();
});
resultOverlay.addEventListener("click", (e) => {
    if (e.target === resultOverlay) {
        hideResultModal();
    }
});

    </script>
</body>
</html>
